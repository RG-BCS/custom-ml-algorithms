# -*- coding: utf-8 -*-
"""perceptron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vBkRx3zcZqLB5_Zuq6uHAsPLXGc655Hl
"""

"""
Majority Vote Classifier

Implements an ensemble classifier that combines multiple classifiers using majority voting.
Supports both class label and probability-based voting strategies.
"""

from sklearn.base import BaseEstimator, ClassifierMixin, clone
from sklearn.preprocessing import LabelEncoder
import numpy as np
from sklearn.utils.estimator_checks import _name_estimators

class MajorityVoteClassifier(BaseEstimator, ClassifierMixin):
    def __init__(self, classifiers, vote='classlabel', weight=None):
        self.classifiers = classifiers
        self.vote = vote
        self.weight = weight
        self.named_classifiers = {key: value for key, value in _name_estimators(classifiers)}

    def fit(self, x, y):
        if self.vote not in ('probability', 'classlabel'):
            raise ValueError(f"vote must be 'probability' or 'classlabel', got: {self.vote}")
        if self.weight and len(self.weight) != len(self.classifiers):
            raise ValueError(f"Number of weights must match number of classifiers. "
                             f"Got {len(self.weight)} weights, {len(self.classifiers)} classifiers.")
        self.labelenc_ = LabelEncoder()
        self.labelenc_.fit(y)
        self.classes_ = self.labelenc_.classes_
        self.classifiers_trained = [clone(clf).fit(x, self.labelenc_.transform(y))
                                    for clf in self.classifiers]
        return self

    def predict(self, x):
        if self.vote == 'probability':
            maj_vote = np.argmax(self.predict_proba(x), axis=1)
        else:
            predictions = np.asarray([clf.predict(x) for clf in self.classifiers_trained])
            maj_vote = np.apply_along_axis(
                lambda x: np.bincount(x, weights=self.weight, minlength=len(self.classes_)),
                axis=0,
                arr=predictions
            )
            maj_vote = np.argmax(maj_vote, axis=0)
        return self.labelenc_.inverse_transform(maj_vote)

    def predict_proba(self, x):
        probas = np.asarray([clf.predict_proba(x) for clf in self.classifiers_trained])
        avg_proba = np.average(probas, axis=0, weights=self.weight)
        return avg_proba

    def get_params(self, deep=True):
        if not deep:
            return super().get_params(deep=False)
        else:
            out = self.named_classifiers.copy()
            for name, step in self.named_classifiers.items():
                for key, value in step.get_params(deep=True).items():
                    out[f'{name}__{key}'] = value
            return out