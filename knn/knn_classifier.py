# -*- coding: utf-8 -*-
"""perceptron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vBkRx3zcZqLB5_Zuq6uHAsPLXGc655Hl
"""

import numpy as np

class KNNClassifier:
    def __init__(self, n_neighbors, random_state=42, metric='minkowski', p=2):
        self.n_neighbors = n_neighbors

        # Normalize known metric names
        if metric == 'euclidean':
            self.metric = 'minkowski'
            self.p = 2
        elif metric == 'manhattan':
            self.metric = 'minkowski'
            self.p = 1
        elif metric == 'minkowski':
            self.metric = metric
            self.p = p
        else:
            raise ValueError(f"Unsupported metric: {metric}")

    def fit(self, x, y):
        batch, input_dim = x.shape
        self.input_dim = input_dim
        assert batch == len(y), "Input batch size must match target size"
        self.x_train = x
        self.y_train = y
        return self

    def predict(self, x):
        pick_classes = self.calc_dis_return_class(x)
        return np.array([np.argmax(np.bincount(row)) for row in pick_classes])

    def predict_proba(self, x):
        pick_classes = self.calc_dis_return_class(x)
        n_classes = len(np.unique(self.y_train))
        return np.array([np.bincount(row, minlength=n_classes) / len(row) for row in pick_classes])

    def calc_dis_return_class(self, x):
        if x.ndim != 2:
            raise ValueError(f"Expected 2D array, got {x.ndim}D array instead. "
                             f"Reshape your data using array.reshape(1, -1) if it's a single sample.")

        if self.metric == 'minkowski':
            sub_x1_x2 = np.abs(self.x_train[:, np.newaxis, :] - x[np.newaxis, :, :])
            if self.p == 2:
                distances = np.sqrt(np.sum((sub_x1_x2) ** self.p, axis=-1)).T
            else:
                distances = np.sum((sub_x1_x2) ** self.p, axis=-1).T
            min_distances_indx = np.argsort(distances, axis=-1)[:, :self.n_neighbors]
            return self.y_train[min_distances_indx]

        else:
            raise ValueError("Unsupported metric")

    def score(self, x_test, y_test):
        y_pred = self.predict(x_test)
        return (y_pred == y_test).sum() / y_test.shape[0]

    def __repr__(self):
        return f"KNNClassifier(n_neighbors={self.n_neighbors}, metric='{self.metric}', p={self.p})"